<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Canary 框架的设计原理与工作流程 | Canary 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/Canary/image/logo_icon.svg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="深度学习分类图像分类模型对抗鲁棒性评估平台">
    
    <link rel="preload" href="/Canary/assets/css/0.styles.28e0b892.css" as="style"><link rel="preload" href="/Canary/assets/js/app.54747c60.js" as="script"><link rel="preload" href="/Canary/assets/js/2.96477923.js" as="script"><link rel="preload" href="/Canary/assets/js/26.49006822.js" as="script"><link rel="prefetch" href="/Canary/assets/js/10.e41ce6db.js"><link rel="prefetch" href="/Canary/assets/js/11.c4122f38.js"><link rel="prefetch" href="/Canary/assets/js/12.79dd4184.js"><link rel="prefetch" href="/Canary/assets/js/13.fde884c5.js"><link rel="prefetch" href="/Canary/assets/js/14.a0af2daf.js"><link rel="prefetch" href="/Canary/assets/js/15.2ba9027a.js"><link rel="prefetch" href="/Canary/assets/js/16.3365723a.js"><link rel="prefetch" href="/Canary/assets/js/17.7e038541.js"><link rel="prefetch" href="/Canary/assets/js/18.31b367f3.js"><link rel="prefetch" href="/Canary/assets/js/19.755ccd6a.js"><link rel="prefetch" href="/Canary/assets/js/20.59197d1c.js"><link rel="prefetch" href="/Canary/assets/js/21.79abe7d2.js"><link rel="prefetch" href="/Canary/assets/js/22.d8d844fc.js"><link rel="prefetch" href="/Canary/assets/js/23.7c049fab.js"><link rel="prefetch" href="/Canary/assets/js/24.71ee39b7.js"><link rel="prefetch" href="/Canary/assets/js/25.d5fbf266.js"><link rel="prefetch" href="/Canary/assets/js/27.ae545721.js"><link rel="prefetch" href="/Canary/assets/js/3.133f5e82.js"><link rel="prefetch" href="/Canary/assets/js/4.7497085b.js"><link rel="prefetch" href="/Canary/assets/js/5.b2e56a73.js"><link rel="prefetch" href="/Canary/assets/js/6.d9a201fd.js"><link rel="prefetch" href="/Canary/assets/js/7.3034c90a.js"><link rel="prefetch" href="/Canary/assets/js/8.01e8e26f.js"><link rel="prefetch" href="/Canary/assets/js/9.b0a1d6a4.js">
    <link rel="stylesheet" href="/Canary/assets/css/0.styles.28e0b892.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Canary/" class="home-link router-link-active"><img src="/Canary/image/logo.svg" alt="Canary 文档" class="logo"> <span class="site-name can-hide">Canary 文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Canary/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Languages" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Canary/en/" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/Canary/start/how-does-canary-run.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  简体中文
</a></li></ul></div></div> <a href="https://github.com/NeoSunJZ/Canary_Master" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Canary/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Languages" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Canary/en/" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/Canary/start/how-does-canary-run.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  简体中文
</a></li></ul></div></div> <a href="https://github.com/NeoSunJZ/Canary_Master" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/Canary/" aria-current="page" class="sidebar-link">Home</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>教程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Canary/start/what_is_adversarial_attack_and_model_robustness.html" class="sidebar-link">什么是对抗攻击与模型鲁棒性？</a></li><li><a href="/Canary/start/how-does-canary-run.html" aria-current="page" class="active sidebar-link">Canary 框架的设计原理与工作流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Canary/start/how-does-canary-run.html#模型推理" class="sidebar-link">模型推理</a></li><li class="sidebar-sub-header"><a href="/Canary/start/how-does-canary-run.html#对抗攻击" class="sidebar-link">对抗攻击</a></li><li class="sidebar-sub-header"><a href="/Canary/start/how-does-canary-run.html#模型-方法基础评估" class="sidebar-link">模型/方法基础评估</a></li><li class="sidebar-sub-header"><a href="/Canary/start/how-does-canary-run.html#模型-方法转移评估" class="sidebar-link">模型/方法转移评估</a></li><li class="sidebar-sub-header"><a href="/Canary/start/how-does-canary-run.html#最后提示" class="sidebar-link">最后提示</a></li></ul></li><li><a href="/Canary/start/get-started-with-canary-sefi.html" class="sidebar-link">开始使用 Canary</a></li><li><a href="/Canary/start/get-started-with-canary-sefi-use-library.html" class="sidebar-link">开始使用 Canary Library</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Canary/guide/how-to-install-canary.html" class="sidebar-link">安装 Canary</a></li><li><a href="/Canary/guide/how-to-configure-clients.html" class="sidebar-link">配置 Canary SEFI</a></li><li><a href="/Canary/guide/integrate_your_own_model.html" class="sidebar-link">模型、数据集集成</a></li><li><a href="/Canary/guide/integrate_your_own_method.html" class="sidebar-link">攻击方法集成</a></li><li><a href="/Canary/guide/how-to-use-canary-lib.html" class="sidebar-link">使用 Canary Library</a></li><li><a href="/Canary/guide/how-to-init-or-recovery-task.html" class="sidebar-link">启动与恢复任务</a></li><li><a href="/Canary/guide/how-to-get-and-handle-synthetical-evaluation-results.html" class="sidebar-link">获取与处理综合评估结果</a></li><li><a href="/Canary/guide/how-to-use-canary-webview.html" class="sidebar-link">使用 Canary WebView</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Canary API参考</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Canary/api/api-reference-for-decorators.html" class="sidebar-link">装饰器的 API 参考</a></li><li><a href="/Canary/api/evaluation_indicators.html" class="sidebar-link">评估指标</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Canary Library 库参考</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/Canary/method_library/method_list" class="sidebar-heading clickable open"><span>已集成的攻击方法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Canary/library/method_list/mim.html" class="sidebar-link">MI-FGSM (MIM)</a></li><li><a href="/Canary/library/method_list/cw.html" class="sidebar-link">C&amp;W</a></li><li><a href="/Canary/library/method_list/qfool.html" class="sidebar-link">qFool</a></li></ul></section></li></ul></section></li><li><a href="/Canary/about.html" class="sidebar-link">关于Canary</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="canary-框架的设计原理与工作流程"><a href="#canary-框架的设计原理与工作流程" class="header-anchor">#</a> Canary 框架的设计原理与工作流程</h1> <p>欢迎来到Canary模型对抗鲁棒性评估框架学习教程！</p> <p>在本章节中，我们将与您一同回顾一些人工智能与人工智能对抗（安全）领域的一些基本知识，并从最实际的工作场景出发，为您讲解<code>Canary</code>的工作原理。我们不希望在本章为您展示过多的代码示例和公式，因此我们将主要以框架结构和评估流程为具体展开。</p> <h2 id="模型推理"><a href="#模型推理" class="header-anchor">#</a> 模型推理</h2> <p>假设您有一个已预训练的图像分类模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>，并有一张图片 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>，若您希望对该图片进行推理并获取结果，只需将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 传入函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 即可得到推理结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>。</p> <p>在任何人工智能框架中这都是正确的流程，然而它可能比理论的设想稍复杂：</p> <p>为了调整模型参数（训练），图片往往需要进行一些必要的预处理，例如像素范围由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mn>5</mn><mn>5</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,255]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mord mathrm">5</span><span class="mclose">]</span></span></span></span> 缩放至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ，或/和加入一些标准化与归一化；除此之外，加载的图片的格式可能并不满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>B</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo separator="true">,</mo><mi>C</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo separator="true">,</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[Batch, Channel, Width, Height]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mclose">]</span></span></span></span> 这种格式。<strong>因此，我们在将图片图片传入模型函数进行预测前，有必要对图片进行处理，这个过程被称为预处理（Pre-Process）。</strong></p> <p>我们希望模型输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 可以视为属于类 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span> 的概率，然后选择具有最大输出值的类别 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">argmax(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 作为我们的预测。例如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">y_3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">.</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">0.1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">.</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">0.8</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">8</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">.</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">0.1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span></span></span></span>，那我们预测的类别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span>。</p> <p>但我们不能将未规范化的预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 直接作为输出，因为将线性层的输出直接视为概率时会存在一些问题：</p> <ul><li>我们没有限制这些数字的总和为1</li> <li>根据输入的不同，它们可以为负值</li></ul> <p>要将输出视为概率，我们必须保证在任何数据上的输出都是非负的且总和为1，为了达成这个目标，我们需要使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Softmax()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">t</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 对这些输出进行处理，然后才能使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">argmax()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 得到最终的推理结果。<strong>因此，我们在将图片图片传入模型函数进行预测后，有必要对模型结果进行处理，这个过程被称为后处理（Post-Process）。</strong></p> <p>在<code>Canary</code>中，我们设计了图片预处理器（Pre-Processer）、结果后处理器（Result-Post-Processer）负责以上两个处理过程。通用的模型预测流程如下所述：</p> <img src="/Canary/image/ModelInference.svg" alt="Model Inference"> <p>我们注意到，图片预处理器 <code>Pre-Processer</code>、结果后处理器 <code>Result-Post-Processer</code> 仅与模型 <code>Model</code> 有关。基于以上知识，我们在<code>Canary</code>中设计了一个通用的模型推理模块，该模型推理模块只需获取 <code>Model</code> 和其对应的 <code>Processer</code> 组件即可完成推理工作。</p> <h2 id="对抗攻击"><a href="#对抗攻击" class="header-anchor">#</a> 对抗攻击</h2> <p>假设您有一个已预训练的图像分类模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>，对抗攻击扰动生成方法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>，并有一张图片 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>，则对抗攻击函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta_{+}()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 可以定义为：找到使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 越过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 的决策边界所需扰动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> ，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub><mo>=</mo><mi>x</mi><mo>+</mo><mi>δ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x_a = x + \delta(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≠</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mi>a</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x) \neq f(x_a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，输出对抗样本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。若您希望基于该图片生成对抗样本并对模型进行对抗攻击，只需将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 和函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>均传递给攻击方法函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta_{+}()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 即可得到推理结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub><mo>=</mo><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">x_a=\delta_{+}(x,f())</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p> <p>对于绝大多数的对抗攻击算法这都是正确的流程，同样的，代码的现实可能比理论的设想稍复杂：</p> <p>在<a href="#%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%B5%81%E7%A8%8B">模型预测流程</a>中我们已经知道，欲计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span>，需使用图片预处理器 <code>Pre-Processer</code>对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 进行处理。此时函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta_{+}(x,f())</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 产生的对抗样本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 将是一个已经预处理的图片，由于可能不满足图片的基本数据结构，它将无法直接保存为图片格式（如<code>PNG</code>/<code>JPEG</code>）。<strong>为了将产生的对抗样本转储为图片，我们还需要对进行逆转预处理过程的处理，这个过程被称为逆处理（Reverse Process）。</strong></p> <p>在<code>Canary</code>中，我们设计了图片逆处理器（Reverse-Processer）负责以上处理过程。通用的对抗攻击流程如下所述：</p> <img src="/Canary/image/AdversarialExampleGeneration.svg" alt="Adversarial Example Generation"> <p>我们注意到，图片逆处理器 <code>Reverse-Processer</code> 和图片预处理器 <code>Pre-Processer</code> 的运算恰好相反，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 在先经过<code>Pre-Processer</code> 再经过 <code>Reverse-Processer</code> 后，仍将保持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 不变。由于 <code>Pre-Processer</code> 仅与模型 <code>Model</code> 有关，<code>Reverse-Processer</code> 也应当仅与模型 <code>Model</code> 有关。</p> <p>基于以上知识，我们在<code>Canary</code>中设计了一个通用的对抗攻击模块，该对抗攻击模块只需获取 <code>Model</code> 和其对应的 <code>Processer</code> 组件、<code>Attack</code>组件即可完成对抗样本生成工作。</p> <h2 id="模型-方法基础评估"><a href="#模型-方法基础评估" class="header-anchor">#</a> 模型/方法基础评估</h2> <p>我们假设您准备了以下组件并托管至<code>Canary</code>（或者，您决定使用<code>Canary Lib</code>中的组件）:</p> <ul><li>模型和处理器：模型 <code>Model</code>，预处理器 <code>Pre-Processer</code>，逆处理器 <code>Reverse-Processer</code>，后处理器 <code>Result-Post-Processer</code></li> <li>攻击方法：攻击方法 <code>Attack</code></li></ul> <p>这些组件将使得我们能够完成<a href="#%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%B5%81%E7%A8%8B">模型预测流程</a>和<a href="#%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B">对抗攻击流程</a>，这两个流程是我们进行“模型鲁棒性-方法有效性” 评估的基础操作。</p> <p>此处的基础评估是指，您基于模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 产生了对抗样本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta_{+}(x,f())</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> （在<code>Canary</code>中我们称该模型为<code>Base Model</code>），并在模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 上继续完成测试（在<code>Canary</code>中我们称该模型为<code>Test Model</code>）。显然，基础评估中 <code>Base Model</code> 与 <code>Test Model</code> <strong>是</strong>同一个模型。</p> <p>Carlini 和 Wagner 认为更有效的对抗样本生成算法需保证如下两个条件：</p> <ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 尽可能充分小（通常 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mrow><mi>p</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><mo>∈</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">l_{p}, p\in(1, 2, \infty)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.01968em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit">p</span><span class="mrel">∈</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">∞</span><span class="mclose">)</span></span></span></span> 度量），同时尽可能无法被人
眼察觉；</li> <li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 尽可能使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> 分类产生错误，且错误的置信度足够的高（对目标攻击而言）。</li></ol> <p>对于模型来说，更具有对抗鲁棒性的模型将使得对抗样本在该模型上表现更差，对同一个攻击方法而已，这意味着更高的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mrow><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">l_{p}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.01968em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，更低的误分类率。</p> <p>为了评估“模型鲁棒性-方法有效性”，首先<strong>我们需要了解扰动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 的大小，以及扰动在图像的可察觉性，这意味着我们需要对比攻击前后的图像差异</strong>；其次<strong>我们需要了解生成的对抗样本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 在多大程度上使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> 分类产生错误，这意味着我们需要对比攻击前后样本的推理结果差异</strong>；最后，<strong>我们需要汇总这些内容以便于进行综合的排名计算</strong>。</p> <p>在<code>Canary</code>中，我们设计了图像对比分析器（Image Difference Analyzer）、结果对比分析器（Result Difference Analyzer）、评估结果汇总（Evaluation Results Summarizer）负责以上三个处理过程。通用的基础评估流程如下所述：</p> <img src="/Canary/image/AdversarialRobustnessEvaluation.svg" alt="Adversarial Robustness Evaluation"> <p>具体来说，通过该过程我们能采集以下三类<a href="/Canary/api/evaluation_indicators.html">评估指标</a>：</p> <ul><li><p><strong>模型能力评估指标 (Model capability measurement metrics)</strong>，由<strong>结果对比分析器</strong>计算：</p> <ul><li>干净样本正确率 (Clear Accuracy, <code>CA</code>)<strong>*</strong></li> <li>干净样本F1分数 (Clear F1, <code>CF</code>)<strong>*</strong></li> <li>干净样本平均正确分类置信度 (Clear Confidence, <code>CC</code>)<strong>*</strong></li></ul></li> <li><p><strong>攻击效果评估指标 (Attack effectiveness measurement metrics)</strong>，由<strong>结果对比分析器</strong>计算：</p> <ul><li>误分类比例 (Misclassification Ratio, <code>MR</code>) / 攻击准确性 (Targeted Attack Success, <code>TAS</code>)</li> <li>对抗样本置信偏移 (Average Confidence Change, <code>ACC</code>):
<ul><li>抗类平均置信增高(Average Increase in Adversarial-class Confidence, <code>AIAC</code>)</li> <li>真实类平均置度降低(Average Reduction in True-class Confidence, <code>ARTC</code>)</li></ul></li> <li>对抗样本模型关注区域偏移 (Average Class Activation Mapping Change, <code>ACAMC</code>) <strong>**</strong></li></ul></li> <li><p><strong>攻击代价评估指标 (Cost of attack measurement metrics)</strong>，由<strong>图像对比分析器</strong>计算：</p> <ul><li>平均范数距离 (Average Norm Distortion, <code>AND</code>):
<ul><li>最大像素距离(Average Maximum Distortion, <code>AMD</code>)</li> <li>平均欧式距离(Average Euclidean Distortion, <code>AED</code>)</li> <li>像素变化比例(Average Pixel Change Ratio, <code>APCR</code>)</li></ul></li> <li>平均频域欧式距离 (Average Euclidean Distortion in Frequency Domain, <code>AED-FD</code>)</li> <li>平均特征相似性 (Average Metrics Similarity, <code>AMS</code>):
<ul><li>平均深度特征相似性(Average Deep Metrics Similarity, <code>ADMS</code>)</li> <li>平均低层特征相似性(Average Low-level MetricsSimilarity, <code>ALMS</code>)</li></ul></li></ul></li></ul> <p><strong>*</strong> 结果分析器，是 结果对比分析器 的子组件之一；
<strong>**</strong> Grad-CAM部分逻辑需依赖模型钩子，不能简单的由图示过程得到，此处仅为简化例。</p> <p><strong><code>Canary</code>很好的支持了“模型鲁棒性-方法有效性” 评估。</strong> 欲开始评估，请进一步参考<code>Canary</code>文档：<a href="/Canary/start/get-started-with-canary-sefi.html">开始使用 Canary</a> 和 <a href="/Canary/start/get-started-with-canary-sefi-use-library.html">开始使用 Canary Library</a>。</p> <p>值得注意的是，在<code>Canary</code>中，<strong>我们使用<code>SQLite</code>管理包含以上的所有测试中的数据</strong>，以便于使用标准<code>SQL</code>进行数据交换与查询。关于<code>SQLite</code>，您可以参阅<a href="https://www.sqlite.org/docs.html" target="_blank" rel="noopener noreferrer">SQLite Documentation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>以获得进一步信息。</p> <h2 id="模型-方法转移评估"><a href="#模型-方法转移评估" class="header-anchor">#</a> 模型/方法转移评估</h2> <p>此处的迁移评估是指，您基于模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 产生了对抗样本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta_{+}(x,f())</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> （<code>Base Model</code>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>），并在模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{\prime}()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 上继续完成测试（<code>Test Model</code>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f^{\prime}()</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>）。显然，迁移评估中 <code>Base Model</code> 与 <code>Test Model</code> <strong>不是</strong>同一个模型。</p> <p>假设我们已经基于模型<code>A</code>，<code>B</code>，<code>C</code>生成了一系列对抗样本<code>Adv A</code>、<code>Adv B</code>、<code>Adv C</code>，生成流程如下所述：</p> <img src="/Canary/image/AttackTestOnThreeModels.svg" alt="Attack Test On Three Models"> <h3 id="完全转移性评估"><a href="#完全转移性评估" class="header-anchor">#</a> 完全转移性评估</h3> <p>一种自然而然的想法是，我们希望全面的了解攻击方法的转移性情况，我们只需使用这些对抗样本分别在不同的模型上测试即可，测试流程如下所述：</p> <img src="/Canary/image/TransferAttackFullTest.svg" alt="Transfer Attack Full Test"> <p>蓝色数据块即为转移攻击的测试结果，以块<code>A-B</code>为例，其意为基于<code>A</code>产生的对抗样本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>A</mi></mrow></msub><mo>(</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta_{+}(x,f_{A}())</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">A</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 在模型 <code>B</code> 上的预测结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>B</mi></mrow></msub><mo>(</mo><msub><mi>δ</mi><mrow><mo>+</mo></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>A</mi></mrow></msub><mo>(</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{B}(\delta_{+}(x,f_{A}())</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03785em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">+</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">A</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。基于蓝色块的数据（只需沿某一轴进行相加以排除不同模型的差异），我们可以观测到两方面信息：</p> <ul><li>什么模型产生的对抗样本是具有更高转移性的（沿测试模型<code>Test Model</code>的轴相加）；</li> <li>什么模型更容易被攻击方法<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span></span></span></span>转移攻击（沿原始模型<code>Base Model</code>的轴相加）。</li></ul> <p>显然的，完全评估有一个显著的弊端，那就是程序员们最讨厌的时间复杂度之一：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。如果我们评估20个模型，基础评估只需要20次，而完全转移评估将高达380次！如此大的代价可能只是让我们更加精确的逼近了真相，这真的值得吗？</p> <h3 id="简易转移性评估"><a href="#简易转移性评估" class="header-anchor">#</a> 简易转移性评估</h3> <p>如果您不是希望探索某种攻击方法的详尽迁移性能，使用<a href="#%E5%AE%8C%E5%85%A8%E8%BD%AC%E7%A7%BB%E6%80%A7%E8%AF%84%E4%BC%B0">完全转移性评估</a>显然不是一个好主意。我们提供了两种简单的转移性评估方法供您选用：</p> <ul><li>如果您希望了解：什么模型产生的对抗样本是具有更高转移性的，测试流程如下所述：</li></ul> <img src="/Canary/image/TransferAttackSimpleTest1.svg" alt="Transfer Attack Simple Test 1"> <ul><li>如果您希望了解：什么模型更容易被攻击方法<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03785em;">δ</span></span></span></span>转移攻击，测试流程如下所述：</li></ul> <img src="/Canary/image/TransferAttackSimpleTest2.svg" alt="Transfer Attack Simple Test 2"> <p>注意：事实上，这一过程不足以使您充分了解什么模型更容易被转移攻击（可能仅仅是对您测试的这一种攻击是这样的），您应当测试多种模型以确定这一点。</p> <p><strong><code>Canary</code>很好的支持了所有的转移测试方式，甚至，我们提供了更加自由的配置方案，允许您完全控制迁移测试过程，以满足更加多样的测试需求。</strong> 欲使用转移评估，请进一步参考<code>Canary</code>文档：</p> <p>通过<a href="#%E6%A8%A1%E5%9E%8B-%E6%96%B9%E6%B3%95%E8%BD%AC%E7%A7%BB%E8%AF%84%E4%BC%B0">模型/方法转移评估</a>我们能采集以下<a href="/Canary/api/evaluation_indicators.html">评估指标</a>：</p> <ul><li><strong>攻击效果评估指标 (Attack effectiveness measurement metrics)</strong>，由<strong>结果对比分析器</strong>计算：
<ul><li>对抗样本可观测转移率 (Observable Transfer Rate, OTR)*</li></ul></li></ul> <p><strong>*</strong> 转移评估分析器，是 结果对比分析器 的子组件之一。</p> <h2 id="最后提示"><a href="#最后提示" class="header-anchor">#</a> 最后提示</h2> <p>恭喜，您已经了解<code>Canary</code>的具体运作机制，包括模型推理、对抗攻击（对抗样本生成）、模型/方法基础评估和转移评估的过程与参与的组件，尽管这些内容并不是<code>Canary</code>的全部功能，但它们是<code>Canary</code>的核心。</p> <p>这里仍然有很多东西值得进一步探究，例如：“模型鲁棒性-方法有效性”的评估是否需要约束对攻击方法的参数进行约束；在使用多个攻击方法评估多个模型后，数据又该如何处理；这些指标究竟是什么；综合的排名计算有哪些方法等等。这些内容我们已经在我们的期刊文章 <a href="https://www.mdpi.com/2079-9292/12/17/3665" target="_blank" rel="noopener noreferrer">CANARY: An Adversarial Robustness Evaluation Platform for Deep Learning Models on Image Classification<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中进行了详细的解答，在本文档的<strong>高级教程</strong>中，我们也进行了额外的扩充。但我们需要请您了解：<strong>我们提供的解决方案不是唯一的正确选项，因此您完全可以自行处理<code>Canary</code>中得到的任何结果，我们也充分的支持了相关操作。</strong></p> <p>在下一章中，我们将引导您使用<code>Canary</code>进行一次针对模型的对抗攻击测试。这一教程将从集成模型、处理器和攻击方法至<code>Canary</code>展开。倘若您更倾向于尝试运行代码而不是面对冗杂的模型与攻击方法准备、集成和调试，则转到 <a href="/Canary/start/get-started-with-canary-sefi-use-library.html">开始使用 Canary Library</a> 继续阅读将给您带来更好体验。</p> <blockquote><p>本章由 <strong>孙家正(Jiazheng Sun)</strong> 编写</p></blockquote></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/NeoSunJZ/Canary_Doc/edit/main/docs/start/how-does-canary-run.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2023/11/28 23:55:13</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Canary/start/what_is_adversarial_attack_and_model_robustness.html" class="prev">
        什么是对抗攻击与模型鲁棒性？
      </a></span> <span class="next"><a href="/Canary/start/get-started-with-canary-sefi.html">
        开始使用 Canary
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Canary/assets/js/app.54747c60.js" defer></script><script src="/Canary/assets/js/2.96477923.js" defer></script><script src="/Canary/assets/js/26.49006822.js" defer></script>
  </body>
</html>
